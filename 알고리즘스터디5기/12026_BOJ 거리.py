# 보도블럭 N개
N = int(input())  # 사용자로부터 보도블록의 개수 N을 입력받음

# 보도블럭에 쓰여 있는 글자 1번부터 순서대로
blocks = input()  # 사용자로부터 보도블록에 쓰여 있는 문자열을 입력받음

# 스타트는 1번, 링크는 N번
# 스타트가 링크를 만나는데 필요한 에너지 양의 최솟값은?
# 만날 수 없으면 -1 출력

# 무조건 B, O, J 순서로 밟아야 하는 건가..? yes

# 1. 상태(dp 배열) 정의
# dp 배열 초기화
inf = 1000000  # 무한대를 의미하는 값으로 초기화, 점프할 수 없는 경우를 표현하기 위함
dp = [inf] * N  # dp 배열을 무한대 값으로 초기화, 각 보도블록에 도달하기 위한 최소 에너지를 저장할 배열

# 3. 초기 조건
dp[0] = 0  # 시작점은 에너지 필요 없으므로 0으로 설정


# 2. 점화식
# 다음 문자 결정하기
def next_char(c):
    # 현재 문자 c가 주어졌을 때 다음에 와야 할 문자를 반환하는 함수
    if c == 'B':
        return 'O'  # B 다음에는 O가 와야 함
    elif c == 'O':
        return 'J'  # O 다음에는 J가 와야 함
    elif c == 'J':
        return 'B'  # J 다음에는 B가 와야 함


# 4.dp 배열 채우기
for i in range(1, N):  # 1번 보도블록부터 N번 보도블록까지 순회
    for j in range(i):  # 현재 보도블록 i에 도달하기 위해 이전 보도블록 j에서 점프하는 경우를 모두 확인
        if blocks[i] == next_char(blocks[j]):  # 만약 현재 보도블록이 이전 보도블록 다음에 와야 하는 문자라면
            # 현재 보도블록 i에 도달하기 위한 최소 에너지를 갱신
            dp[i] = min(dp[i], dp[j] + (i - j) ** 2)  # j에서 i로 점프하는데 필요한 에너지를 계산하여 최소값을 찾음

# 결과 출력
# dp 배열의 마지막 원소(dp[N - 1])가 무한대가 아니라면 해당 값을 출력
# 만약 무한대라면 스타트가 링크를 만날 수 없으므로 -1을 출력
print(dp[N - 1] if dp[N - 1] != inf else -1)
